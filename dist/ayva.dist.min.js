var e={d:(t,s)=>{for(var i in s)e.o(s,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:s[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{kZ:()=>f,UE:()=>v,fV:()=>x,we:()=>m,ft:()=>M,ni:()=>E,_I:()=>P,ZP:()=>f});const s=class{#e;#t=[];constructor(e){this.#e=e,Object.values(e.axes).forEach((e=>{this[e.name]=this.#s(e.name),e.alias&&(this[e.alias]=this.#s(e.alias))}))}execute(){return this.#e.move(...this.#t)}#s(e){return(...t)=>{if(3===t.length&&"number"==typeof t[0]&&"number"==typeof t[1]&&"function"==typeof t[2])this.#t.push({axis:e,to:t[0],speed:t[1],value:t[2]});else if(2===t.length&&"number"==typeof t[0]&&"number"==typeof t[1])this.#t.push({axis:e,to:t[0],speed:t[1]});else if(2===t.length&&"number"==typeof t[0]&&"function"==typeof t[1])this.#t.push({axis:e,to:t[0],value:t[1]});else if(1===t.length&&"number"==typeof t[0])this.#t.push({axis:e,to:t[0]});else if(2===t.length&&"function"==typeof t[0]&&"number"==typeof t[1])this.#t.push({axis:e,value:t[0],duration:t[1]});else if(1===t.length&&"function"==typeof t[0])this.#t.push({axis:e,value:t[0]});else{if(1!==t.length||"object"!=typeof t[0])throw new Error(`Invalid arguments: ${t}`);this.#t.push({...t[0],axis:e})}return this}}};function i(e,t=0){const s=10**t;return Math.round(s*e)/s}function o(e,t,s){return Math.max(t,Math.min(s,e))}function a(e,t,s){return!(!Number.isFinite(e)||void 0!==t&&e<t||void 0!==s&&e>s)}function r(e,t,s){Object.defineProperty(e,t,{value:s,writeable:!1,configurable:!1,enumerable:!0})}function n(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function c(e){throw new Error(e)}const h={validateMovements(e,t,s){const i={};let o=!1,a=!1;e&&e.length||c("Must supply at least one movement."),e.forEach((e=>{e&&"object"==typeof e||c(`Invalid movement: ${e}`);const r=t=>c(`Invalid value for parameter '${t}': ${e[t]}`),h=n(e,"to"),u=n(e,"speed"),p=n(e,"duration"),l=n(e,"value"),m=e.axis||s;if(m||c("No default axis configured. Must specify an axis for each movement."),n(e,"axis")&&("string"==typeof e.axis&&e.axis.trim()&&t[e.axis]||r("axis")),h){let s=!1;s="boolean"===t[m].type?"boolean"!=typeof e.to:!Number.isFinite(e.to)||e.to<0||e.to>1,s&&r("to")}else l||c("Must provide a 'to' property or 'value' function.");u&&p&&c("Cannot supply both speed and duration."),(u||p)&&(o=!0,u&&(!Number.isFinite(e.speed)||e.speed<=0)?r("speed"):p&&(!Number.isFinite(e.duration)||e.duration<=0)&&r("duration")),u&&!h&&c("Must provide a target position when specifying speed."),l&&"function"!=typeof e.value&&c("'value' must be a function."),n(e,"sync")&&("string"==typeof e.sync&&e.sync.trim()||r("sync"),(n(e,"speed")||n(e,"duration"))&&c(`Cannot specify a speed or duration when sync property is present: ${e.axis}`)),"boolean"!==t[m].type?a=!0:(n(e,"speed")&&c(`Cannot specify speed for boolean axes: ${m}`),n(e,"duration")&&h&&!l&&c("Cannot specify a duration for a boolean axis movement with constant value.")),i[m]&&c(`Duplicate axis movement: ${m}`),i[m]=e,t[m].alias&&(i[t[m].alias]=e)})),e.forEach((e=>{let t=e;const s=e.axis;for(;n(t,"sync");)i[t.sync]||c(`Cannot sync with axis not specified in movement: ${t.axis} -> ${t.sync}`),t=i[t.sync],t.sync===s&&c("Sync axes cannot form a cycle.")})),!o&&a&&c("At least one movement must have a speed or duration.")},validateAxisConfig(e){e&&"object"==typeof e||c(`Invalid configuration object: ${e}`);const t={name:"string",type:"string",alias:"string",max:"number",min:"number"},s=["name","type"].filter((t=>void 0===e[t]||null===e[t])).sort();s.length&&c(`Configuration is missing properties: ${s.join(", ")}`);const i=[];Object.keys(t).forEach((s=>{const o=e[s];null!=o&&(typeof o!==t[s]?i.push(s):"min"!==s&&"max"!==s||(!Number.isFinite(o)||o<0||o>1)&&i.push(s))}));let{defaultValue:o}=e;null!=o?"boolean"===e.type?"boolean"!=typeof o&&i.push("defaultValue"):(!Number.isFinite(o)||o<0||o>1)&&i.push("defaultValue"):o="boolean"!==e.type&&("auxiliary"===e.type?0:.5),i.length&&c(`Invalid configuration parameter(s): ${i.sort().map((t=>`${t} = ${e[t]}`)).join(", ")}`),-1===["linear","rotation","auxiliary","boolean"].indexOf(e.type)&&c(`Invalid type. Must be linear, rotation, auxiliary, or boolean: ${e.type}`);const a={...e,defaultValue:o,max:e.max||1,min:e.min||0,value:o,lastValue:o};return(a.max===a.min||a.min>a.max)&&c(`Invalid configuration parameter(s): max = ${a.max}, min = ${a.min}`),a},validateMotionParameters(e,t,s,i,o,r){if(!(a(e,0,1)&&a(t,0,1)&&a(s)&&a(i)&&a(o)&&o>0&&a(r)))throw new Error(`One or more motion parameters are invalid (${e}, ${t}, ${s}, ${i}, ${o}, ${r})`)}},u={name:"SR6",defaultAxis:"L0",axes:[{name:"L0",type:"linear",alias:"stroke"},{name:"L1",type:"linear",alias:"forward"},{name:"L2",type:"linear",alias:"left"},{name:"R0",type:"rotation",alias:"twist"},{name:"R1",type:"rotation",alias:"roll"},{name:"R2",type:"rotation",alias:"pitch"},{name:"A0",alias:"valve",type:"auxiliary"},{name:"A1",alias:"suck",type:"auxiliary"},{name:"A2",alias:"lube",type:"auxiliary",resetOnStop:!0},{name:"V0",alias:"vibe0",type:"auxiliary",resetOnStop:!0},{name:"V1",alias:"vibe1",type:"auxiliary",resetOnStop:!0}]},p=class extends Function{constructor(){return super("...args","return this.__bound__.__call__(...args)"),this.__bound__=Function.prototype.bind.call(this,this),this.__bound__}__call__(...e){throw new Error("__call__ not implemented.")}};class l extends p{complete=!1;#i;#o=!1;#e=null;#a;#r;#n;get ayva(){return this.#e}constructor(e){if(super(),e){if("GeneratorFunction"!==e.constructor.name)throw Error(`Not a generator function: ${e}`);this.generate=e}}*start(e){}*generate(e){throw new Error("generate() not implemented.")}*iterated(e,t=1){for(let s=0;s<t;s++)yield*this.generate(e)}perform(e=this.#e){const t=this.#c(e);return t?Array.isArray(t)?e.move(...t):Number.isFinite(t)&&t>=0?e.ready().then((()=>e.sleep(t))):t instanceof s?t.execute():t instanceof Promise?t:e.move(t):Promise.resolve()}bind(e){return this.unbind(),this.#e=e,this.#a=this.start,this.#r=this.generate,this.#n=this.iterated,this.start=this.start.bind(this,e),this.generate=this.generate.bind(this,e),this.iterated=this.iterated.bind(this,e),this}unbind(){this.#e&&(this.#e=null,this.start=this.#a,this.generate=this.#r,this.iterated=this.#n)}#c(e){this.#i&&!this.#o||(this.#i=this.generate(e),this.#o=!1);const{value:t,done:s}=this.#i.next();return this.#o=s,s?null:t}__call__(...e){const t=this.#e?e[0]:e[1],s=this.#e||e[0],i=Number.isFinite(t)&&t>=1?t:void 0;return this.#e?i?this.iterated(i):this.generate():i?this.iterated(s,i):this.generate(s)}[Symbol.iterator](){return this.generate()}}const m=l;class d{#h=[];#u={};#p=50;#l=new Set;#m=1;#d=1;#f=null;#v=!1;#y;#g=new Set;#x=new Set;defaultRamp=d.RAMP_COS;static get precision(){return 10}get performing(){return this.#v}get axes(){const e={};return Object.keys(this.#u).forEach((t=>{e[t]=this.getAxis(t)})),e}get frequency(){return this.#p}get period(){return this.#b}get#b(){return 1/this.#p}constructor(e){r(this,"$",{}),e&&this.#w(e),"undefined"==typeof Worker?this.#y={sleep:e=>new Promise((t=>{setTimeout(t,1e3*e)})),now:()=>performance.now()/1e3}:this.#y=new class{#A;#R={};#M=1;constructor(){this.#A=new Worker(this.#E((function(){onmessage=function(e){const{id:t,delay:s}=e.data;setTimeout((()=>{postMessage(t)}),1e3*s)}}))),this.#A.onmessage=({data:e})=>{const t=e;this.#R[t](),delete this.#R[t]}}sleep(e){return new Promise((t=>{const s=this.#M++;this.#R[s]=t,this.#A.postMessage({id:s,delay:e})}))}now(){return performance.now()/1e3}#E(e){const t=new Blob([`(${e.toString()})()`],{type:"text/javascript"});return URL.createObjectURL(t)}}}defaultConfiguration(){return this.#w(u),this}getTimer(){return this.#y}async do(e){this.stop();const t=this.#d++;for(this.#f=t;this.#v;)await this.sleep();this.#v=!0;const s=this.#P(e);for(;this.#f===t&&!s.complete;)try{await s.perform(this),await this.ready()}catch(e){console.error("Error performing behavior:",e?.stack);break}return this.#v=!1,this.#f===t&&(this.#f=null,!0)}async move(...e){if(!this.#h||!this.#h.length)throw new Error("No output devices have been added.");h.validateMovements(e,this.#u,this.defaultAxis);const t=this.#m++;for(this.#l.add(t);this.#l.has(t)&&this.#l.values().next().value!==t;)await this.sleep();return!!this.#l.has(t)&&this.#L(t,e).finally((()=>{this.#l.delete(t),this.#$()}))}ready(){return this.#g.size||this.#l.size?new Promise((e=>{this.#x.add(e)})):Promise.resolve()}moveBuilder(){return new s(this)}async home(e=.5){const t=this.#S().map((t=>{const s={axis:t.name,to:t.defaultValue};return"boolean"!==t.type&&(s.speed=e),s}));return t.length?this.move(...t):(console.warn("No linear or rotation axes configured."),Promise.resolve(!1))}stop(){this.#f=null,this.#l.clear(),this.#g.forEach((e=>e())),this.#S().forEach((e=>{e.resetOnStop&&(this.$[e.name].value=e.defaultValue)}))}sleep(e){let t;const s=new Promise((e=>{this.#g.add(e),t=e}));return Promise.any([this.#y.sleep(e).then((()=>!0)),s.then((()=>!1))]).finally((()=>{this.#g.delete(t),this.#$()}))}configureAxis(e){const t=h.validateAxisConfig(e),s=this.#u[e.name];if(s&&(t.value=s.value,t.lastValue=s.lastValue,delete this.#u[s.alias],delete this.$[s.alias]),this.#u[e.name]=t,this.#O(e.name),e.alias){if(this.#u[e.alias])throw new Error(`Alias already refers to another axis: ${e.alias}`);this.#u[e.alias]=t,this.#O(e.alias)}}getAxis(e){const t=this.#u[e];if(t){const e={};return Object.keys(t).forEach((s=>{r(e,s,t[s])})),e}}getAxes(){return this.#S().map((e=>({name:e.name,alias:e.alias,type:e.type,defaultValue:e.defaultValue,max:e.max,min:e.min,value:e.value,lastValue:e.lastValue,resetOnStop:e.resetOnStop})))}updateLimits(e,t,s){const i=e=>!Number.isFinite(e)||e<0||e>1;if(i(t)||i(s)||t===s)throw new Error(`Invalid limits: min = ${t}, max = ${s}`);if(!this.#u[e])throw new Error(`Invalid axis: ${e}`);this.#u[e].min=Math.min(t,s),this.#u[e].max=Math.max(t,s)}addOutput(...e){this.addOutputDevice(...e)}getOutput(){return this.getOutputDevices()}removeOutput(e){this.removeOutputDevice(e)}addOutputDevice(...e){const t=e.map((e=>{const t=e&&e.write&&e.write instanceof Function;if(!(t||e instanceof Function))throw new Error(`Invalid device: ${e}`);return t?e:{write:e}}));this.#h.push(...t)}getOutputDevices(){return[...this.#h]}removeOutputDevice(e){const t=this.#h.indexOf(e);-1!==t&&this.#h.splice(t,1)}stroke(...e){return this.$.stroke(...e).execute()}left(...e){return this.$.left(...e).execute()}forward(...e){return this.$.forward(...e).execute()}twist(...e){return this.$.twist(...e).execute()}roll(...e){return this.$.roll(...e).execute()}pitch(...e){return this.$.pitch(...e).execute()}#O(e){Object.defineProperty(this.$,e,{value:(...t)=>this.moveBuilder()[e](...t),writeable:!1,configurable:!0,enumerable:!0}),Object.defineProperty(this.$[e],"value",{get:()=>this.#u[e].value,set:t=>{const{type:s}=this.#u[e];if("boolean"!==s&&!a(t,0,1))throw new Error(`Invalid value: ${t}`);const i="boolean"===s?!!t:t,o=this.#_(e,i);this.#k(`${o}\n`),this.#u[e].lastValue=this.#u[e].value,this.#u[e].value=i}}),Object.defineProperty(this.$[e],"lastValue",{get:()=>this.#u[e].lastValue}),Object.defineProperty(this.$[e],"defaultValue",{get:()=>this.#u[e].defaultValue}),Object.defineProperty(this.$[e],"min",{get:()=>this.#u[e].min}),Object.defineProperty(this.$[e],"max",{get:()=>this.#u[e].max})}#w(e){this.name=e.name,this.defaultAxis=e.defaultAxis,this.#p=e.frequency||this.#p,e.axes&&e.axes.forEach((e=>{this.configureAxis(e)}))}#P(e){return"function"!=typeof e||e instanceof m?e:function(e){return"GeneratorFunction"===e.constructor.name}(e)?new m(e):{perform:e}}#k(e){for(const t of this.#h)t.write(e)}async#L(e,t){const s=this.#I(t),{duration:i,stepCount:o}=this.#F(s),a=s.filter((e=>!e.parameters.stepCount)),r=s.filter((e=>!!e.parameters.stepCount));this.#T(a,0);let n=0;const c=this.#y.now();if(o)for(let t=0;t<o;t++){const s=r.filter((e=>t<e.parameters.stepCount));if(this.#T(s,t),n=await this.#j(t,o,i,c,n),!this.#l.has(e))return!1}else await this.sleep(this.#b);return!0}async#j(e,t,s,i,o){if(e===t-1){const e=this.#y.now()-i,t=Math.min(Math.max(s-e,0),this.#b);await this.sleep(t)}else await this.sleep(this.#b-o);return this.#y.now()-i-(e+1)*this.#b}#T(e,t){const s=e.map((e=>this.#C(e,t))).filter((({value:e})=>this.#V(e))),i=s.map((({axis:e,value:t})=>this.#_(e,t)));i.length&&(this.#k(`${i.join(" ")}\n`),s.forEach((({axis:e,value:t})=>{this.#u[e].lastValue=this.#u[e].value,this.#u[e].value=t})))}#C(e,t){const s=t*this.#b,{parameters:a,valueProvider:r}=e,{duration:n}=a,c=r({...a,time:s,index:t,period:this.#b,frequency:this.#p,currentValue:this.#u[a.axis].value,x:Math.min(1,(t+1)/(n*this.#p))}),h=null!=c;return!this.#V(c)&&h&&console.warn(`Invalid value provided: ${c}`),{axis:a.axis,value:Number.isFinite(c)?o(i(c,d.precision),0,1):c}}#V(e){return Number.isFinite(e)||"boolean"==typeof e}#_(e,t){let s;if("boolean"==typeof t)s=t?"9999":"0000";else{const{min:a,max:r}=this.#u[e],n=i(.9999*t,4);s=`${o(i(1e4*((r-a)*n+a)),0,9999)}`.padStart(4,"0")}return`${this.#u[e].name}${s}`}#I(e){const{parameterObjects:t,maxDuration:s}=this.#q(e);return this.#B(t,s),t.map((e=>{const t={};return n(e,"value")?t.valueProvider=e.value:"boolean"===this.#u[e.axis].type?t.valueProvider=()=>e.to:e.to!==e.from?t.valueProvider=this.defaultRamp:t.valueProvider=()=>{},delete e.sync,delete e.value,t.parameters=e,t}))}#q(e){let t=0;const s=e.map((e=>{const s=e.axis||this.defaultAxis,o={...e,axis:s,from:this.#u[s].value,period:this.#b};if(n(e,"to")){const t=e.to-o.from,s=Math.abs(t);n(e,"duration")?o.speed=i(s/e.duration,d.precision):n(e,"speed")&&(o.duration=i(s/o.speed,d.precision)),o.direction=t>0?1:t<0?-1:0}return n(o,"duration")&&(t=Math.max(o.duration,t)),o}));return{maxDuration:t,parameterObjects:s}}#B(e,t){const s=e.reduce(((e,t)=>(e[t.axis]=t,this.#u[t.axis].alias&&(e[this.#u[t.axis].alias]=t),e)),{});e.forEach((e=>{if(n(e,"sync")){let o=e;for(;n(o,"sync");)o=s[o.sync];e.duration=o.duration||t,n(e,"to")&&(e.speed=i(Math.abs(e.to-e.from)/e.duration,d.precision))}else n(e,"duration")||"boolean"===this.#u[e.axis].type||(e.duration=t);n(e,"duration")&&(e.stepCount=Math.ceil(e.duration*this.#p))}))}#F(e){let t=0,s=0;return e.forEach((e=>{const i=e.parameters.stepCount,o=e.parameters.duration;i&&(t=Math.max(i,t)),o&&(s=Math.max(o,s))})),{duration:s,stepCount:t}}#S(){const e={};return Object.values(this.#u).forEach((t=>{e[t.name]=t})),Object.values(e).sort((function(e,t){return e.name>t.name?1:-1}))}#$(){if(0===this.#g.size&&0===this.#l.size&&this.#x.size){for(const e of this.#x)e();this.#x.clear()}}static ramp(e){return t=>{const{from:s,to:i}=t;return s+(i-s)*e(t)}}static RAMP_LINEAR(e){return d.ramp((({x:e})=>e))(e)}static RAMP_COS(e){return d.ramp((({x:e})=>-Math.cos(Math.PI*e)/2+.5))(e)}static RAMP_PARABOLIC(e){return d.ramp((({x:e})=>e*e))(e)}static RAMP_NEGATIVE_PARABOLIC(e){return d.ramp((({x:e})=>1-(e-1)**2))(e)}static tempestMotion(e,t,s=0,i=0,o=60,a=0){h.validateMotionParameters(e,t,s,i,o,a);const r=2*Math.PI*o/60,n=.5*(t-e),c=.5*(t+e),u=({index:e,frequency:t})=>{const o=(e+1)*r/t+.5*Math.PI*s+a;return c-n*Math.cos(o+i*Math.sin(o))};return d.#N(u,e,t,s,i,o),u}static parabolicMotion(e,t,s=0,i=0,o=60,a=0){h.validateMotionParameters(e,t,s,i,o,a);const{sin:r,PI:n}=Math,c=2*n*o/60,u=t-e,p=t,l=({index:e,frequency:t})=>{const o=(e+1)*c/t+.5*n*s+a,h=(o%(l=2*n)+l)%l/n-1+i/n*r(o);var l;return p-u*h*h};return d.#N(l,e,t,s,i,o),l}static linearMotion(e,t,s=0,i=0,o=60,a=0){h.validateMotionParameters(e,t,s,i,o,a);const{abs:r,sin:n,PI:c}=Math,u=2*c*o/60,p=t-e,l=t,m=({index:e,frequency:t})=>{const o=(e+1)*u/t+.5*c*s+a,h=(o%(m=2*c)+m)%m/c-1+i/c*n(o);var m;return l-p*r(h)};return d.#N(m,e,t,s,i,o),m}static#N(e,t,s,i,o,a){r(e,"from",t),r(e,"to",s),r(e,"phase",i),r(e,"ecc",o),r(e,"bpm",a)}static blendMotion(e,t,s){return(...o)=>i((1-s)*e(...o)+s*t(...o),d.precision)}static get defaultConfiguration(){return{...u}}static map(e,t,s,i=0,o=1){return(e-t)*(o-i)/(s-t)+i}}const f=d,v=class{#D=[];#U=!1;get complete(){return this.#U}generateActions(e){throw new Error("Behavior does not implement generateActions()")}emitActions(e=1,t=null){for(let s=0;s<e;s++)this.generateActions(t);return this.#D.splice(0,this.#D.length)}async perform(e){if(this.#D.length||this.generateActions(e),!this.#D.length)throw new Error("Behavior did not generate any actions.");const{type:t,value:i}=this.#D.shift();if("function"===t&&i instanceof Function)return i.call(void 0,this,e);if("sleep"===t&&Number.isFinite(i)&&i>=0)return e.sleep(i);if("move"===t&&i instanceof s)return i.execute();if("move"===t&&i instanceof Array)return e.move(...i);throw new Error(`Invalid action: (${t}, ${i})`)}queueMove(...e){const t=e[0]instanceof s?e[0]:e;this.#G({type:"move",value:t})}queueSleep(e){this.#G({type:"sleep",value:e})}queueFunction(e){this.#G({type:"function",value:e})}queueBehavior(e,t=1,s=null){this.#W(e.emitActions(t,s))}queueComplete(){this.queueFunction((()=>{this.#U=!0}))}insertMove(...e){const t=e[0]instanceof s?e[0]:e;this.#z({type:"move",value:t})}insertSleep(e){this.#z({type:"sleep",value:e})}insertFunction(e){this.#z({type:"function",value:e})}insertBehavior(e,t=1,s=null){this.#Z(e.emitActions(t,s))}insertComplete(){this.insertFunction((()=>{this.#U=!0}))}#G(e){this.#D.push(e)}#W(e){this.#D.splice(this.#D.length,0,...e)}#z(e){this.#D.unshift(e)}#Z(e){this.#D.splice(0,0,...e)}};class y{#J=0;#H;constructor(e){this.#H=e}next(){return this.#H(this.#J++)}get index(){return this.#J}static createFrom(e){return new y(e instanceof Array?t=>e[t%e.length]:"function"!=typeof e?()=>e:e)}}class g extends m{#K;#Q;#X;#Y;#ee;get speed(){return this.#X}get top(){return this.#K}get bottom(){return this.#Q}get duration(){return this.#Y}static get DEFAULT_CONFIG(){return{top:1,bottom:0,speed:1,shape:f.RAMP_COS,relativeSpeeds:[1,1],suck:null,twist:null,pitch:null}}constructor(e=0,t=1,s=1,i=f.RAMP_COS){let o;super(),o="object"!=typeof e||e instanceof Array?{top:t,bottom:e,speed:s,shape:i}:e,this.#te(o)}*generate(e){const{value:t,lastValue:s}=e.$.stroke,{target:i,shape:o,direction:r,relativeSpeed:n}=this.#se(t,s),c=this.#X*n,h={to:i,value:o};void 0!==this.#ee.speed?(h.speed=c,this.#X=this.#ee.speed.next()):(h.duration=this.#Y/n,this.#Y=this.#ee.duration.next());const u=[h];this.#ee.twist&&u.push(this.#ie("twist",{direction:r,value:t,target:i,ayva:e,speed:void 0!==this.#ee.speed?c:Math.abs(i-t)/h.duration})),this.#ee.pitch&&u.push(this.#ie("pitch",{direction:r,value:t,target:i,ayva:e,speed:void 0!==this.#ee.speed?c:Math.abs(i-t)/h.duration})),a(this.#ee.suck,0,1)&&(e.$.suck.value=this.#ee.suck),yield u}#te(e){const t=g.DEFAULT_CONFIG;n(e,"duration")&&delete t.speed;const s={...t,...e};this.#oe(s),s.top=y.createFrom(s.top),s.bottom=y.createFrom(s.bottom),s.relativeSpeeds=y.createFrom(s.relativeSpeeds),n(s,"duration")?s.duration=y.createFrom(s.duration):s.speed=y.createFrom(s.speed);const{shape:i}=s;s.shape=new y(i instanceof Array?e=>i[e%i.length]:()=>i),this.#ee=s,this.#K=this.#ee.top.next(),this.#Q=this.#ee.bottom.next(),void 0!==this.#ee.speed?this.#X=this.#ee.speed.next():this.#Y=this.#ee.duration.next()}#ie(e,{direction:t,value:s,target:i,speed:o,ayva:a}){const{frequency:r}=a,n=("up"===t?0:2)+(this.#ee[e].phase||0),c=this.#ee[e].ecc||0,h=60*o/(2*Math.abs(s-i)),u=f.tempestMotion(this.#ee[e].from,this.#ee[e].to,n,c,h),p=u({index:-1,frequency:r});return Math.abs(p-a.$[e].value)>.05?{axis:e,to:f.tempestMotion(this.#ee[e].from,this.#ee[e].to,n+2,c,h)({index:-1,frequency:r}),value:f.RAMP_COS}:{axis:e,value:u}}#se(e,t){const s=e-t>=0,i=this.#ee.shape.index%2==0?"up":"down",o=this.#ee.relativeSpeeds.index%2==0?"up":"down";let a,r;return e<=this.#Q||e<this.#K&&!s?(r="up",a=this.#K,this.#K=this.#ee.top.next(),"down"===i&&this.#ee.shape.next(),"down"===o&&this.#ee.relativeSpeeds.next()):(r="down",a=this.#Q,this.#Q=this.#ee.bottom.next(),"up"===i&&this.#ee.shape.next(),"up"===o&&this.#ee.relativeSpeeds.next()),{target:a,shape:this.#ee.shape.next(),direction:r,relativeSpeed:this.#ee.relativeSpeeds.next()}}#oe(e){const t=(e,t)=>{throw new Error(`Invalid stroke ${e}: ${t}`)};if(a(e.bottom,0,1)||"function"==typeof e.bottom||e.bottom instanceof Array||t("bottom",e.bottom),a(e.top,0,1)||"function"==typeof e.top||e.top instanceof Array||t("top",e.top),e.bottom===e.top)throw new Error(`Invalid stroke range specified: (${e.bottom}, ${e.top})`);if(n(e,"speed")&&n(e,"duration"))throw new Error("Cannot specify both a speed and duration");if(!n(e,"speed")||a(e.speed)&&!(e.speed<=0)||"function"==typeof e.speed||e.speed instanceof Array||t("speed",e.speed),!n(e,"duration")||a(e.duration)&&!(e.duration<=0)||"function"==typeof e.duration||e.duration instanceof Array||t("duration",e.duration),"function"==typeof e.shape||e.shape instanceof Array||t("shape",e.shape),!n(e,"relativeSpeeds")||e.relativeSpeeds instanceof Array||t("relative speeds",e.relativeSpeeds),["twist","pitch"].forEach((s=>{"object"!=typeof e[s]&&t(s,e[s]),e[s]&&(a(e[s].from,0,1)||t(`${s} from`,e[s].from),a(e[s].to,0,1)||t(`${s} to`,e[s].to),n(e[s],"phase")&&!a(e[s].phase)&&t(`${s} phase`,e[s].phase))})),e.shape instanceof Array){if(!e.shape.length)throw new Error("Missing stroke shape.");if(e.shape.length%2!=0)throw new Error("Must specify an even number of stroke shapes.");e.shape.forEach((e=>{"function"!=typeof e&&t("shape",e)}))}if(e.relativeSpeeds instanceof Array){if(e.relativeSpeeds.length%2!=0)throw new Error("Must specify an even number of relative speeds.");e.relativeSpeeds.forEach((e=>{(!a(e)||e<=0)&&t("relative speed",e)}))}n(e,"suck")&&!a(e.suck,0,1)&&null!==e.suck&&t("suck",e.suck)}}const x=g,b=[{name:"down-forward",L0:{from:0,to:1,phase:0,ecc:.5},L1:{from:.8,to:.2,phase:1,ecc:.8},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:.2,to:.8,phase:1,ecc:.8}},{name:"down-backward",L0:{from:0,to:1,phase:0,ecc:.5},L1:{from:.2,to:.8,phase:1,ecc:.8},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:.8,to:.2,phase:1,ecc:.8}},{name:"back-thrust-down",L0:{from:0,to:.7,phase:0,ecc:.5},L1:{from:1,to:0,phase:0,ecc:.5},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:.4,to:1,phase:0,ecc:.5}},{name:"back-thrust-down-swirl",L0:{from:0,to:.7,phase:0,ecc:.5},L1:{from:.9,to:.1,phase:0,ecc:.5},L2:{from:.8,to:.2,phase:1,ecc:.5},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.8,to:.2,phase:1,ecc:.5},R2:{from:.5,to:1,phase:0,ecc:.5}},{name:"thrust-forward",L0:{from:0,to:.5,phase:0,ecc:.5},L1:{from:.2,to:1,phase:0,ecc:.5},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:.5,to:1,phase:0,ecc:.5}},{name:"thrust-forward-swirl",L0:{from:0,to:.5,phase:0,ecc:.5},L1:{from:.2,to:1,phase:0,ecc:.5},L2:{from:.8,to:.2,phase:1,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.8,to:.2,phase:1,ecc:0},R2:{from:.5,to:1,phase:0,ecc:.5}},{name:"lean-forward-thrust-down",L0:{from:0,to:.7,phase:0,ecc:.5},L1:{from:.5,to:.5,phase:0,ecc:0},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:1,to:0,phase:0,ecc:.5}},{name:"lean-forward-thrust-down-swirl",L0:{from:0,to:.7,phase:0,ecc:.5},L1:{from:.5,to:.5,phase:0,ecc:0},L2:{from:.8,to:.2,phase:1,ecc:.5},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.8,to:.2,phase:1,ecc:.5},R2:{from:1,to:0,phase:0,ecc:.5}},{name:"diagonal-down-back",L0:{from:0,to:.5,phase:0,ecc:.2},L1:{from:1,to:.2,phase:0,ecc:.2},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:1,to:0,phase:1,ecc:.6}},{name:"diagonal-down-forward",L0:{from:0,to:.5,phase:0,ecc:.2},L1:{from:0,to:.8,phase:0,ecc:.2},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:0,to:1,phase:1,ecc:.6}},{name:"orbit-tease",L0:{from:.8,to:1,phase:0,ecc:.3},L1:{from:.9,to:.1,phase:0,ecc:-.3},L2:{from:.1,to:.9,phase:1,ecc:-.3},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.1,to:.9,phase:1,ecc:-.3},R2:{from:.1,to:.9,phase:0,ecc:-.3}},{name:"left-right-tease",L0:{from:.9,to:.9,phase:0,ecc:0},L1:{from:.5,to:.5,phase:0,ecc:0},L2:{from:0,to:1,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:1,to:0,phase:1,ecc:0},R2:{from:.5,to:.5,phase:0,ecc:0}},{name:"forward-back-tease",L0:{from:.9,to:.9,phase:0,ecc:0},L1:{from:0,to:1,phase:0,ecc:0},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:0,to:1,phase:1,ecc:0}},{name:"vortex-tease",L0:{from:.8,to:1,phase:0,ecc:.3},L1:{from:.6,to:.4,phase:0,ecc:0},L2:{from:.4,to:.6,phase:1,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.9,to:.1,phase:1,ecc:0},R2:{from:.9,to:.1,phase:0,ecc:0}},{name:"swirl-tease",L0:{from:.5,to:1,phase:0,ecc:0},L1:{from:1,to:.3,phase:0,ecc:0},L2:{from:1,to:0,phase:1,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.9,to:.1,phase:1,ecc:0},R2:{from:.4,to:1,phase:0,ecc:0}},{name:"forward-back-grind",L0:{from:0,to:0,phase:0,ecc:0},L1:{from:.3,to:.7,phase:0,ecc:0},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:0,to:1,phase:.5,ecc:0}},{name:"orbit-grind",L0:{from:0,to:.3,phase:0,ecc:.3},L1:{from:0,to:.6,phase:0,ecc:-.3},L2:{from:.2,to:.8,phase:1,ecc:-.3},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.1,to:.9,phase:1,ecc:-.3},R2:{from:.9,to:.1,phase:0,ecc:-.3}}].reduce(((e,t)=>{const{name:s}=t;return delete t.name,e[s]=t,e}),{});class w extends m{#ae;#re;#ne;get angle(){return this.#ae}set angle(e){this.#ae=e}get bpm(){return this.#re}static#ce=36;static set granularity(e){if(!a(e,1))throw new Error(`Invalid granularity: ${e}`);w.#ce=e}static get granularity(){return w.#ce}static get DEFAULT_PARAMETERS(){return{from:0,to:1,phase:0,ecc:0,shift:0,motion:f.tempestMotion}}static get library(){return JSON.parse(JSON.stringify(b))}constructor(e,t=60,s=0){if(super(),"string"==typeof e){if(!n(b,e))throw new Error(`No stroke named ${e} found.`);e=b[e]}r(this,"axes",{}),Object.keys(e).forEach((t=>{r(this.axes,t,{}),Object.keys(e[t]).forEach((s=>{r(this.axes[t],s,e[t][s])})),Object.keys(w.DEFAULT_PARAMETERS).forEach((s=>{n(e[t],s)||r(this.axes[t],s,w.DEFAULT_PARAMETERS[s])}))})),this.#ae=s,this.#ne=y.createFrom(t),this.#re=this.#ne.next()}*generate(){const{granularity:e}=w;for(let t=0;t<e;t++)yield this.#he(t);this.#ae+=Math.PI}*start(e,t){const s=this.getStartMoves(e,t);yield s}getStartMoves(e,t){const s={};t&&(n(t,"speed")||n(t,"duration"))||(s.speed=1);const i={};return[...Object.keys(this.axes).map((o=>{i[e.getAxis(o).name]=!0;const a=this.axes[o];return{axis:o,to:a.motion(a.from,a.to,a.phase,a.ecc,this.#re,a.shift+this.#ae)({index:-1,frequency:e.frequency}),...s,...t}})),...e.getAxes().filter((e=>!i[e.name])).map((e=>{const i={axis:e.name,to:e.defaultValue,...s,...t};return"boolean"===e.type&&(delete i.speed,delete i.duration),i}))]}transition(e,t=60,s=1,i=null,o=null){return new A(e,t,this,s,i,o)}#he(e){const{granularity:t}=w,s=Object.keys(this.axes).map((s=>{const i=this.axes[s],o=30/t,a=Math.PI/t;return{axis:s,value:i.motion(i.from,i.to,i.phase,i.ecc,this.#re,i.shift+this.#ae+e*a),duration:o/this.#re}}));return this.#re=this.#ne.next(),s}}class A extends w{#ee;#ue;#pe;#le;constructor(e,t,s,i,o,a){super(e,t),this.angle=R.computeTransitionStartAngle(s,i,this.bpm),this.#ue=new R(s,this,i),this.#ee=e,this.#pe=o,this.#le=a,s.ayva&&(this.bind(s.ayva),this.#ue.bind(s.ayva))}*generate(e){this.#ue.complete||(this.#pe instanceof Function&&this.#pe(this.#ue.duration,this.bpm),yield*this.#ue(),this.#le instanceof Function&&this.#le(this.#ee,this.bpm)),yield*super.generate(e)}}class R extends m{#me;#de;#Y;get duration(){return this.#Y}constructor(e,t,s){super(),this.#me=e,this.#de=t,this.#Y=s}*generate(e){if(!(e instanceof f))throw new TypeError(`Invalid Ayva instance: ${e}`);const t={...w.DEFAULT_PARAMETERS,from:.5,to:.5},s={...w.DEFAULT_PARAMETERS,from:0,to:0},i=this.#fe(this.#me.axes,e),o=this.#fe(this.#de.axes,e),a={};Object.keys(o).forEach((r=>{const n="auxiliary"===e.getAxis(r).type?s:t,c=i[r]??{...n},h=o[r];a[r]=this.#ve(c,h)})),Object.keys(i).forEach((o=>{if(!a[o]){const r="auxiliary"===e.getAxis(o).type?s:t,n=i[o],c={...r};a[o]=this.#ve(n,c)}}));const r=[];Object.keys(a).forEach((e=>{r.push({axis:e,...a[e]})})),yield r,this.complete=!0}#ve(e,t){const s=this.#me.bpm,i=(this.#me.bpm+this.#de.bpm)/2;return{value:o=>{const{x:a}=o,r=f.map(a,0,1,e.from,t.from),n=f.map(a,0,1,e.to,t.to),c=f.map(a,0,1,e.phase,t.phase),h=f.map(a,0,1,e.ecc,t.ecc),u=f.map(a,0,1,s,i);return f.blendMotion(e.motion(r,n,c,h,u,this.#me.angle),t.motion(r,n,c,h,u,this.#me.angle),a)(o)},duration:this.#Y}}#fe(e,t){return Object.keys(e).reduce(((s,i)=>(s[t.getAxis(i).name]=e[i],s)),{})}static computeTransitionStartAngle(e,t,s){const i=(e.bpm+s)/2;return e.angle+2*Math.PI*(i/60)*t}}const M=w,E=class{#ye;#ge;constructor(e,t){if(a(e,0)&&void 0===t)this.#ge=1e3*e;else{if(!(a(e,0)&&a(t,0)&&e<t))throw new Error(`Invalid duration range: (${e}, ${t})`);this.#ge=1e3*(Math.random()*(t-e)+e)}this.#ye=performance.now()}get targetElapsed(){return this.#ge}get complete(){return performance.now()-this.#ye>=this.#ge}get percentage(){return o((performance.now()-this.#ye)/this.#ge,0,1)}},P=class{connected=!1;_baudRate;_output=null;_input=null;_serial=null;constructor(e=115200,t=null){this._baudRate=e,this._serial=t||(globalThis.navigator?globalThis.navigator.serial:null)}async requestConnection(){const e=await this._serial.requestPort();await e.open({baudRate:this._baudRate});const t=new TextEncoderStream;t.readable.pipeTo(e.writable);const s=new TextDecoderStream;e.readable.pipeTo(s.writable),this._output=t.writable.getWriter(),this._input=s.readable.getReader(),this.connected=!0;const i=t=>{t.target===e&&(this.connected=!1,this._serial.removeEventListener("disconnect",i))};return this._serial.addEventListener("disconnect",i),new Promise((e=>{setTimeout(e,2e3)}))}write(e){if(!this.connected)throw new Error("No device connected.");this._output.write(e)}};var L=t.kZ,$=t.UE,S=t.fV,O=t.we,_=t.ft,k=t.ni,I=t._I,F=t.ZP;export{L as Ayva,$ as AyvaBehavior,S as ClassicStroke,O as GeneratorBehavior,_ as TempestStroke,k as VariableDuration,I as WebSerialDevice,F as default};