var e={d:(t,s)=>{for(var o in s)e.o(s,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:s[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{kZ:()=>f,UE:()=>v,fV:()=>x,we:()=>m,ft:()=>M,ni:()=>E,_I:()=>P,ZP:()=>f});const s=class{#e;#t=[];constructor(e){this.#e=e,Object.values(e.axes).forEach((e=>{this[e.name]=this.#s(e.name),e.alias&&(this[e.alias]=this.#s(e.alias))}))}execute(){return this.#e.move(...this.#t)}#s(e){return(...t)=>{if(3===t.length&&"number"==typeof t[0]&&"number"==typeof t[1]&&"function"==typeof t[2])this.#t.push({axis:e,to:t[0],speed:t[1],value:t[2]});else if(2===t.length&&"number"==typeof t[0]&&"number"==typeof t[1])this.#t.push({axis:e,to:t[0],speed:t[1]});else if(2===t.length&&"number"==typeof t[0]&&"function"==typeof t[1])this.#t.push({axis:e,to:t[0],value:t[1]});else if(1===t.length&&"number"==typeof t[0])this.#t.push({axis:e,to:t[0]});else if(2===t.length&&"function"==typeof t[0]&&"number"==typeof t[1])this.#t.push({axis:e,value:t[0],duration:t[1]});else if(1===t.length&&"function"==typeof t[0])this.#t.push({axis:e,value:t[0]});else{if(1!==t.length||"object"!=typeof t[0])throw new Error(`Invalid arguments: ${t}`);this.#t.push({...t[0],axis:e})}return this}}};function o(e,t=0){const s=10**t;return Math.round(s*e)/s}function i(e,t,s){return Math.max(t,Math.min(s,e))}function r(e,t,s){return!(!Number.isFinite(e)||void 0!==t&&e<t||void 0!==s&&e>s)}function a(e,t,s){Object.defineProperty(e,t,{value:s,writeable:!1,configurable:!1,enumerable:!0})}function n(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function c(e){throw new Error(e)}const h={validateMovements(e,t,s){const o={};let i=!1,r=!1;e&&e.length||c("Must supply at least one movement."),e.forEach((e=>{e&&"object"==typeof e||c(`Invalid movement: ${e}`);const a=t=>c(`Invalid value for parameter '${t}': ${e[t]}`),h=n(e,"to"),u=n(e,"speed"),p=n(e,"duration"),l=n(e,"value"),m=e.axis||s;if(m||c("No default axis configured. Must specify an axis for each movement."),n(e,"axis")&&("string"==typeof e.axis&&e.axis.trim()&&t[e.axis]||a("axis")),h){let s=!1;s="boolean"===t[m].type?"boolean"!=typeof e.to:!Number.isFinite(e.to)||e.to<0||e.to>1,s&&a("to")}else l||c("Must provide a 'to' property or 'value' function.");u&&p&&c("Cannot supply both speed and duration."),(u||p)&&(i=!0,u&&(!Number.isFinite(e.speed)||e.speed<=0)?a("speed"):p&&(!Number.isFinite(e.duration)||e.duration<=0)&&a("duration")),u&&!h&&c("Must provide a target position when specifying speed."),l&&"function"!=typeof e.value&&c("'value' must be a function."),n(e,"sync")&&("string"==typeof e.sync&&e.sync.trim()||a("sync"),(n(e,"speed")||n(e,"duration"))&&c(`Cannot specify a speed or duration when sync property is present: ${e.axis}`)),"boolean"!==t[m].type?r=!0:(n(e,"speed")&&c(`Cannot specify speed for boolean axes: ${m}`),n(e,"duration")&&h&&!l&&c("Cannot specify a duration for a boolean axis movement with constant value.")),o[m]&&c(`Duplicate axis movement: ${m}`),o[m]=e,t[m].alias&&(o[t[m].alias]=e)})),e.forEach((e=>{let t=e;const s=e.axis;for(;n(t,"sync");)o[t.sync]||c(`Cannot sync with axis not specified in movement: ${t.axis} -> ${t.sync}`),t=o[t.sync],t.sync===s&&c("Sync axes cannot form a cycle.")})),!i&&r&&c("At least one movement must have a speed or duration.")},validateAxisConfig(e){e&&"object"==typeof e||c(`Invalid configuration object: ${e}`);const t={name:"string",type:"string",alias:"string",max:"number",min:"number"},s=["name","type"].filter((t=>void 0===e[t]||null===e[t])).sort();s.length&&c(`Configuration is missing properties: ${s.join(", ")}`);const o=[];Object.keys(t).forEach((s=>{const i=e[s];null!=i&&(typeof i!==t[s]?o.push(s):"min"!==s&&"max"!==s||(!Number.isFinite(i)||i<0||i>1)&&o.push(s))}));let{defaultValue:i}=e;null!=i?"boolean"===e.type?"boolean"!=typeof i&&o.push("defaultValue"):(!Number.isFinite(i)||i<0||i>1)&&o.push("defaultValue"):i="boolean"!==e.type&&("auxiliary"===e.type?0:.5),o.length&&c(`Invalid configuration parameter(s): ${o.sort().map((t=>`${t} = ${e[t]}`)).join(", ")}`),-1===["linear","rotation","auxiliary","boolean"].indexOf(e.type)&&c(`Invalid type. Must be linear, rotation, auxiliary, or boolean: ${e.type}`);const r={...e,defaultValue:i,max:e.max||1,min:e.min||0,value:i,lastValue:i};return(r.max===r.min||r.min>r.max)&&c(`Invalid configuration parameter(s): max = ${r.max}, min = ${r.min}`),r},validateMotionParameters(e,t,s,o,i,a){if(!(r(e,0,1)&&r(t,0,1)&&r(s)&&r(o)&&r(i)&&i>0&&r(a)))throw new Error(`One or more motion parameters are invalid (${e}, ${t}, ${s}, ${o}, ${i}, ${a})`)}},u={name:"SR6",defaultAxis:"L0",axes:[{name:"L0",type:"linear",alias:"stroke"},{name:"L1",type:"linear",alias:"forward"},{name:"L2",type:"linear",alias:"left"},{name:"R0",type:"rotation",alias:"twist"},{name:"R1",type:"rotation",alias:"roll"},{name:"R2",type:"rotation",alias:"pitch"},{name:"A0",alias:"valve",type:"auxiliary"},{name:"A1",alias:"suck",type:"auxiliary"},{name:"A2",alias:"lube",type:"auxiliary",resetOnStop:!0},{name:"V0",alias:"vibe0",type:"auxiliary",resetOnStop:!0},{name:"V1",alias:"vibe1",type:"auxiliary",resetOnStop:!0}]},p=class extends Function{constructor(){return super("...args","return this.__bound__.__call__(...args)"),this.__bound__=Function.prototype.bind.call(this,this),this.__bound__}__call__(...e){throw new Error("__call__ not implemented.")}};class l extends p{complete=!1;#o;#i=!1;#e=null;#r;#a;#n;get ayva(){return this.#e}constructor(e){if(super(),e){if("GeneratorFunction"!==e.constructor.name)throw Error(`Not a generator function: ${e}`);this.generate=e}}*start(e){}*generate(e){throw new Error("generate() not implemented.")}*iterated(e,t=1){for(let s=0;s<t;s++)yield*this.generate(e)}perform(e=this.#e){const t=this.#c(e);return t?Array.isArray(t)?e.move(...t):Number.isFinite(t)&&t>=0?e.ready().then((()=>e.sleep(t))):t instanceof s?t.execute():t instanceof Promise?t:e.move(t):Promise.resolve()}bind(e){return this.unbind(),this.#e=e,this.#r=this.start,this.#a=this.generate,this.#n=this.iterated,this.start=this.start.bind(this,e),this.generate=this.generate.bind(this,e),this.iterated=this.iterated.bind(this,e),this}unbind(){this.#e&&(this.#e=null,this.start=this.#r,this.generate=this.#a,this.iterated=this.#n)}#c(e){this.#o&&!this.#i||(this.#o=this.generate(e),this.#i=!1);const{value:t,done:s}=this.#o.next();return this.#i=s,s?null:t}__call__(...e){const t=this.#e?e[0]:e[1],s=this.#e||e[0],o=Number.isFinite(t)&&t>=1?t:void 0;return this.#e?o?this.iterated(o):this.generate():o?this.iterated(s,o):this.generate(s)}[Symbol.iterator](){return this.generate()}}const m=l;class d{#h=[];#u={};#p=50;#l=new Set;#m=1;#d=1;#f=null;#v=!1;#y;#g=new Set;#x=new Set;defaultRamp=d.RAMP_COS;static get precision(){return 10}get performing(){return this.#v}get axes(){const e={};return Object.keys(this.#u).forEach((t=>{e[t]=this.getAxis(t)})),e}get frequency(){return this.#p}get period(){return this.#b}get#b(){return 1/this.#p}constructor(e){a(this,"$",{}),e&&this.#w(e),"undefined"==typeof Worker?this.#y={sleep:e=>new Promise((t=>{setTimeout(t,1e3*e)})),now:()=>performance.now()/1e3}:this.#y=new class{#A;#R={};#M=1;constructor(){this.#A=new Worker(this.#E((function(){onmessage=function(e){const{id:t,delay:s}=e.data;setTimeout((()=>{postMessage(t)}),1e3*s)}}))),this.#A.onmessage=({data:e})=>{const t=e;this.#R[t](),delete this.#R[t]}}sleep(e){return new Promise((t=>{const s=this.#M++;this.#R[s]=t,this.#A.postMessage({id:s,delay:e})}))}now(){return performance.now()/1e3}#E(e){const t=new Blob([`(${e.toString()})()`],{type:"text/javascript"});return URL.createObjectURL(t)}}}defaultConfiguration(){return this.#w(u),this}getTimer(){return this.#y}async do(e){this.stop();const t=this.#d++;for(this.#f=t;this.#v;)await this.sleep();this.#v=!0;const s=this.#P(e);for(;this.#f===t&&!s.complete;)try{await s.perform(this),await this.ready()}catch(e){console.error("Error performing behavior:",e?.stack);break}return this.#v=!1,this.#f===t&&(this.#f=null,!0)}async move(...e){if(!this.#h||!this.#h.length)throw new Error("No output devices have been added.");h.validateMovements(e,this.#u,this.defaultAxis);const t=this.#m++;for(this.#l.add(t);this.#l.has(t)&&this.#l.values().next().value!==t;)await this.sleep();return!!this.#l.has(t)&&this.#L(t,e).finally((()=>{this.#l.delete(t),this.#$()}))}ready(){return this.#g.size||this.#l.size?new Promise((e=>{this.#x.add(e)})):Promise.resolve()}moveBuilder(){return new s(this)}async home(e=.5){const t=this.#S().map((t=>{const s={axis:t.name,to:t.defaultValue};return"boolean"!==t.type&&(s.speed=e),s}));return t.length?this.move(...t):(console.warn("No linear or rotation axes configured."),Promise.resolve(!1))}stop(){this.#f=null,this.#l.clear(),this.#g.forEach((e=>e())),this.#S().forEach((e=>{e.resetOnStop&&(this.$[e.name].value=e.defaultValue)}))}sleep(e){let t;const s=new Promise((e=>{this.#g.add(e),t=e}));return Promise.any([this.#y.sleep(e).then((()=>!0)),s.then((()=>!1))]).finally((()=>{this.#g.delete(t),this.#$()}))}configureAxis(e){const t=h.validateAxisConfig(e),s=this.#u[e.name];if(s&&(t.value=s.value,t.lastValue=s.lastValue,delete this.#u[s.alias],delete this.$[s.alias]),this.#u[e.name]=t,this.#O(e.name),e.alias){if(this.#u[e.alias])throw new Error(`Alias already refers to another axis: ${e.alias}`);this.#u[e.alias]=t,this.#O(e.alias)}}getAxis(e){const t=this.#u[e];if(t){const e={};return Object.keys(t).forEach((s=>{a(e,s,t[s])})),e}}getAxes(){return this.#S().map((e=>({name:e.name,alias:e.alias,type:e.type,defaultValue:e.defaultValue,max:e.max,min:e.min,value:e.value,lastValue:e.lastValue,resetOnStop:e.resetOnStop})))}updateLimits(e,t,s){const o=e=>!Number.isFinite(e)||e<0||e>1;if(o(t)||o(s)||t===s)throw new Error(`Invalid limits: min = ${t}, max = ${s}`);if(!this.#u[e])throw new Error(`Invalid axis: ${e}`);this.#u[e].min=Math.min(t,s),this.#u[e].max=Math.max(t,s)}addOutput(...e){this.addOutputDevice(...e)}getOutput(){return this.getOutputDevices()}removeOutput(e){this.removeOutputDevice(e)}addOutputDevice(...e){const t=e.map((e=>{const t=e&&e.write&&e.write instanceof Function;if(!(t||e instanceof Function))throw new Error(`Invalid device: ${e}`);return t?e:{write:e}}));this.#h.push(...t)}getOutputDevices(){return[...this.#h]}removeOutputDevice(e){const t=this.#h.indexOf(e);-1!==t&&this.#h.splice(t,1)}stroke(...e){return this.$.stroke(...e).execute()}left(...e){return this.$.left(...e).execute()}forward(...e){return this.$.forward(...e).execute()}twist(...e){return this.$.twist(...e).execute()}roll(...e){return this.$.roll(...e).execute()}pitch(...e){return this.$.pitch(...e).execute()}#O(e){Object.defineProperty(this.$,e,{value:(...t)=>this.moveBuilder()[e](...t),writeable:!1,configurable:!0,enumerable:!0}),Object.defineProperty(this.$[e],"value",{get:()=>this.#u[e].value,set:t=>{const{type:s}=this.#u[e];if("boolean"!==s&&!r(t,0,1))throw new Error(`Invalid value: ${t}`);const o="boolean"===s?!!t:t,i=this.#_(e,o);this.#k(`${i}\n`),this.#u[e].lastValue=this.#u[e].value,this.#u[e].value=o}}),Object.defineProperty(this.$[e],"lastValue",{get:()=>this.#u[e].lastValue}),Object.defineProperty(this.$[e],"defaultValue",{get:()=>this.#u[e].defaultValue}),Object.defineProperty(this.$[e],"min",{get:()=>this.#u[e].min}),Object.defineProperty(this.$[e],"max",{get:()=>this.#u[e].max})}#w(e){this.name=e.name,this.defaultAxis=e.defaultAxis,this.#p=e.frequency||this.#p,e.axes&&e.axes.forEach((e=>{this.configureAxis(e)}))}#P(e){return"function"!=typeof e||e instanceof m?e:function(e){return"GeneratorFunction"===e.constructor.name}(e)?new m(e):{perform:e}}#k(e){for(const t of this.#h)t.write(e)}async#L(e,t){const s=this.#I(t),{duration:o,stepCount:i}=this.#F(s),r=s.filter((e=>!e.parameters.stepCount)),a=s.filter((e=>!!e.parameters.stepCount));this.#T(r,0);let n=0;const c=this.#y.now();if(i)for(let t=0;t<i;t++){const s=a.filter((e=>t<e.parameters.stepCount));if(this.#T(s,t),n=await this.#j(t,i,o,c,n),!this.#l.has(e))return!1}else await this.sleep(this.#b);return!0}async#j(e,t,s,o,i){if(e===t-1){const e=this.#y.now()-o,t=Math.min(Math.max(s-e,0),this.#b);await this.sleep(t)}else await this.sleep(this.#b-i);return this.#y.now()-o-(e+1)*this.#b}#T(e,t){const s=e.map((e=>this.#C(e,t))).filter((({value:e})=>this.#V(e))),o=s.map((({axis:e,value:t})=>this.#_(e,t)));o.length&&(this.#k(`${o.join(" ")}\n`),s.forEach((({axis:e,value:t})=>{this.#u[e].lastValue=this.#u[e].value,this.#u[e].value=t})))}#C(e,t){const s=t*this.#b,{parameters:r,valueProvider:a}=e,{duration:n}=r,c=a({...r,time:s,index:t,period:this.#b,frequency:this.#p,currentValue:this.#u[r.axis].value,x:Math.min(1,(t+1)/(n*this.#p))}),h=null!=c;return!this.#V(c)&&h&&console.warn(`Invalid value provided: ${c}`),{axis:r.axis,value:Number.isFinite(c)?i(o(c,d.precision),0,1):c}}#V(e){return Number.isFinite(e)||"boolean"==typeof e}#_(e,t){let s;if("boolean"==typeof t)s=t?"9999":"0000";else{const{min:r,max:a}=this.#u[e],n=o(.9999*t,4);s=`${i(o(1e4*((a-r)*n+r)),0,9999)}`.padStart(4,"0")}return`${this.#u[e].name}${s}`}#I(e){const{parameterObjects:t,maxDuration:s}=this.#q(e);return this.#B(t,s),t.map((e=>{const t={};return n(e,"value")?t.valueProvider=e.value:"boolean"===this.#u[e.axis].type?t.valueProvider=()=>e.to:e.to!==e.from?t.valueProvider=this.defaultRamp:t.valueProvider=()=>{},delete e.sync,delete e.value,t.parameters=e,t}))}#q(e){let t=0;const s=e.map((e=>{const s=e.axis||this.defaultAxis,i={...e,axis:s,from:this.#u[s].value,period:this.#b};if(n(e,"to")){const t=e.to-i.from,s=Math.abs(t);n(e,"duration")?i.speed=o(s/e.duration,d.precision):n(e,"speed")&&(i.duration=o(s/i.speed,d.precision)),i.direction=t>0?1:t<0?-1:0}return n(i,"duration")&&(t=Math.max(i.duration,t)),i}));return{maxDuration:t,parameterObjects:s}}#B(e,t){const s=e.reduce(((e,t)=>(e[t.axis]=t,this.#u[t.axis].alias&&(e[this.#u[t.axis].alias]=t),e)),{});e.forEach((e=>{if(n(e,"sync")){let i=e;for(;n(i,"sync");)i=s[i.sync];e.duration=i.duration||t,n(e,"to")&&(e.speed=o(Math.abs(e.to-e.from)/e.duration,d.precision))}else n(e,"duration")||"boolean"===this.#u[e.axis].type||(e.duration=t);n(e,"duration")&&(e.stepCount=Math.ceil(e.duration*this.#p))}))}#F(e){let t=0,s=0;return e.forEach((e=>{const o=e.parameters.stepCount,i=e.parameters.duration;o&&(t=Math.max(o,t)),i&&(s=Math.max(i,s))})),{duration:s,stepCount:t}}#S(){const e={};return Object.values(this.#u).forEach((t=>{e[t.name]=t})),Object.values(e).sort((function(e,t){return e.name>t.name?1:-1}))}#$(){if(0===this.#g.size&&0===this.#l.size&&this.#x.size){for(const e of this.#x)e();this.#x.clear()}}static ramp(e){return t=>{const{from:s,to:o}=t;return s+(o-s)*e(t)}}static RAMP_LINEAR(e){return d.ramp((({x:e})=>e))(e)}static RAMP_COS(e){return d.ramp((({x:e})=>-Math.cos(Math.PI*e)/2+.5))(e)}static RAMP_PARABOLIC(e){return d.ramp((({x:e})=>e*e))(e)}static RAMP_NEGATIVE_PARABOLIC(e){return d.ramp((({x:e})=>1-(e-1)**2))(e)}static tempestMotion(e,t,s=0,o=0,i=60,r=0){h.validateMotionParameters(e,t,s,o,i,r);const a=2*Math.PI*i/60,n=.5*(t-e),c=.5*(t+e),u=({index:e,frequency:t})=>{const i=(e+1)*a/t+.5*Math.PI*s+r;return c-n*Math.cos(i+o*Math.sin(i))};return d.#N(u,e,t,s,o,i),u}static parabolicMotion(e,t,s=0,o=0,i=60,r=0){h.validateMotionParameters(e,t,s,o,i,r);const{sin:a,PI:n}=Math,c=2*n*i/60,u=t-e,p=t,l=({index:e,frequency:t})=>{const i=(e+1)*c/t+.5*n*s+r,h=(i%(l=2*n)+l)%l/n-1+o/n*a(i);var l;return p-u*h*h};return d.#N(l,e,t,s,o,i),l}static linearMotion(e,t,s=0,o=0,i=60,r=0){h.validateMotionParameters(e,t,s,o,i,r);const{abs:a,sin:n,PI:c}=Math,u=2*c*i/60,p=t-e,l=t,m=({index:e,frequency:t})=>{const i=(e+1)*u/t+.5*c*s+r,h=(i%(m=2*c)+m)%m/c-1+o/c*n(i);var m;return l-p*a(h)};return d.#N(m,e,t,s,o,i),m}static#N(e,t,s,o,i,r){a(e,"from",t),a(e,"to",s),a(e,"phase",o),a(e,"ecc",i),a(e,"bpm",r)}static blendMotion(e,t,s){return(...i)=>o((1-s)*e(...i)+s*t(...i),d.precision)}static get defaultConfiguration(){return{...u}}static map(e,t,s,o=0,i=1){return(e-t)*(i-o)/(s-t)+o}}const f=d,v=class{#D=[];#U=!1;get complete(){return this.#U}generateActions(e){throw new Error("Behavior does not implement generateActions()")}emitActions(e=1,t=null){for(let s=0;s<e;s++)this.generateActions(t);return this.#D.splice(0,this.#D.length)}async perform(e){if(this.#D.length||this.generateActions(e),!this.#D.length)throw new Error("Behavior did not generate any actions.");const{type:t,value:o}=this.#D.shift();if("function"===t&&o instanceof Function)return o.call(void 0,this,e);if("sleep"===t&&Number.isFinite(o)&&o>=0)return e.sleep(o);if("move"===t&&o instanceof s)return o.execute();if("move"===t&&o instanceof Array)return e.move(...o);throw new Error(`Invalid action: (${t}, ${o})`)}queueMove(...e){const t=e[0]instanceof s?e[0]:e;this.#G({type:"move",value:t})}queueSleep(e){this.#G({type:"sleep",value:e})}queueFunction(e){this.#G({type:"function",value:e})}queueBehavior(e,t=1,s=null){this.#W(e.emitActions(t,s))}queueComplete(){this.queueFunction((()=>{this.#U=!0}))}insertMove(...e){const t=e[0]instanceof s?e[0]:e;this.#z({type:"move",value:t})}insertSleep(e){this.#z({type:"sleep",value:e})}insertFunction(e){this.#z({type:"function",value:e})}insertBehavior(e,t=1,s=null){this.#Z(e.emitActions(t,s))}insertComplete(){this.insertFunction((()=>{this.#U=!0}))}#G(e){this.#D.push(e)}#W(e){this.#D.splice(this.#D.length,0,...e)}#z(e){this.#D.unshift(e)}#Z(e){this.#D.splice(0,0,...e)}};class y{#J=0;#H;constructor(e){this.#H=e}next(){return this.#H(this.#J++)}get index(){return this.#J}static createFrom(e){return new y(e instanceof Array?t=>e[t%e.length]:"function"!=typeof e?()=>e:e)}}class g extends m{#K;#Q;#X;#Y;#ee;get speed(){return this.#X}get top(){return this.#K}get bottom(){return this.#Q}get duration(){return this.#Y}static get DEFAULT_CONFIG(){return{top:1,bottom:0,speed:1,shape:f.RAMP_COS,relativeSpeeds:[1,1],suck:null,twist:null,pitch:null}}constructor(e=0,t=1,s=1,o=f.RAMP_COS){let i;super(),i="object"!=typeof e||e instanceof Array?{top:t,bottom:e,speed:s,shape:o}:e,this.#te(i)}*generate(e){const{value:t,lastValue:s}=e.$.stroke,{target:o,shape:i,direction:a,relativeSpeed:n}=this.#se(t,s),c=this.#X*n,h={to:o,value:i};void 0!==this.#ee.speed?(h.speed=c,this.#X=this.#ee.speed.next()):(h.duration=this.#Y/n,this.#Y=this.#ee.duration.next());const u=[h];this.#ee.twist&&u.push(this.#oe("twist",{direction:a,value:t,target:o,ayva:e,speed:void 0!==this.#ee.speed?c:Math.abs(o-t)/h.duration})),this.#ee.pitch&&u.push(this.#oe("pitch",{direction:a,value:t,target:o,ayva:e,speed:void 0!==this.#ee.speed?c:Math.abs(o-t)/h.duration})),r(this.#ee.suck,0,1)&&(e.$.suck.value=this.#ee.suck),yield u}#te(e){const t=g.DEFAULT_CONFIG;n(e,"duration")&&delete t.speed;const s={...t,...e};this.#ie(s),s.top=y.createFrom(s.top),s.bottom=y.createFrom(s.bottom),s.relativeSpeeds=y.createFrom(s.relativeSpeeds),n(s,"duration")?s.duration=y.createFrom(s.duration):s.speed=y.createFrom(s.speed);const{shape:o}=s;s.shape=new y(o instanceof Array?e=>o[e%o.length]:()=>o),this.#ee=s,this.#K=this.#ee.top.next(),this.#Q=this.#ee.bottom.next(),void 0!==this.#ee.speed?this.#X=this.#ee.speed.next():this.#Y=this.#ee.duration.next()}#oe(e,{direction:t,value:s,target:o,speed:i,ayva:r}){const{frequency:a}=r,n=("up"===t?0:2)+(this.#ee[e].phase||0),c=this.#ee[e].ecc||0,h=60*i/(2*Math.abs(s-o)),u=f.tempestMotion(this.#ee[e].from,this.#ee[e].to,n,c,h),p=u({index:-1,frequency:a});return Math.abs(p-r.$[e].value)>.05?{axis:e,to:f.tempestMotion(this.#ee[e].from,this.#ee[e].to,n+2,c,h)({index:-1,frequency:a}),value:f.RAMP_COS}:{axis:e,value:u}}#se(e,t){const s=e-t>=0,o=this.#ee.shape.index%2==0?"up":"down",i=this.#ee.relativeSpeeds.index%2==0?"up":"down";let r,a;return e<=this.#Q||e<this.#K&&!s?(a="up",r=this.#K,this.#K=this.#ee.top.next(),"down"===o&&this.#ee.shape.next(),"down"===i&&this.#ee.relativeSpeeds.next()):(a="down",r=this.#Q,this.#Q=this.#ee.bottom.next(),"up"===o&&this.#ee.shape.next(),"up"===i&&this.#ee.relativeSpeeds.next()),{target:r,shape:this.#ee.shape.next(),direction:a,relativeSpeed:this.#ee.relativeSpeeds.next()}}#ie(e){const t=(e,t)=>{throw new Error(`Invalid stroke ${e}: ${t}`)};if(r(e.bottom,0,1)||"function"==typeof e.bottom||e.bottom instanceof Array||t("bottom",e.bottom),r(e.top,0,1)||"function"==typeof e.top||e.top instanceof Array||t("top",e.top),e.bottom===e.top)throw new Error(`Invalid stroke range specified: (${e.bottom}, ${e.top})`);if(n(e,"speed")&&n(e,"duration"))throw new Error("Cannot specify both a speed and duration");if(!n(e,"speed")||r(e.speed)&&!(e.speed<=0)||"function"==typeof e.speed||e.speed instanceof Array||t("speed",e.speed),!n(e,"duration")||r(e.duration)&&!(e.duration<=0)||"function"==typeof e.duration||e.duration instanceof Array||t("duration",e.duration),"function"==typeof e.shape||e.shape instanceof Array||t("shape",e.shape),!n(e,"relativeSpeeds")||e.relativeSpeeds instanceof Array||t("relative speeds",e.relativeSpeeds),["twist","pitch"].forEach((s=>{"object"!=typeof e[s]&&t(s,e[s]),e[s]&&(r(e[s].from,0,1)||t(`${s} from`,e[s].from),r(e[s].to,0,1)||t(`${s} to`,e[s].to),n(e[s],"phase")&&!r(e[s].phase)&&t(`${s} phase`,e[s].phase))})),e.shape instanceof Array){if(!e.shape.length)throw new Error("Missing stroke shape.");if(e.shape.length%2!=0)throw new Error("Must specify an even number of stroke shapes.");e.shape.forEach((e=>{"function"!=typeof e&&t("shape",e)}))}if(e.relativeSpeeds instanceof Array){if(e.relativeSpeeds.length%2!=0)throw new Error("Must specify an even number of relative speeds.");e.relativeSpeeds.forEach((e=>{(!r(e)||e<=0)&&t("relative speed",e)}))}n(e,"suck")&&!r(e.suck,0,1)&&null!==e.suck&&t("suck",e.suck)}}const x=g,b=[{name:"down-forward",L0:{from:0,to:1,phase:0,ecc:.5},L1:{from:.8,to:.2,phase:1,ecc:.8},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:.2,to:.8,phase:1,ecc:.8}},{name:"down-backward",L0:{from:0,to:1,phase:0,ecc:.5},L1:{from:.2,to:.8,phase:1,ecc:.8},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:.8,to:.2,phase:1,ecc:.8}},{name:"back-thrust-down",L0:{from:0,to:.7,phase:0,ecc:.5},L1:{from:1,to:0,phase:0,ecc:.5},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:.4,to:1,phase:0,ecc:.5}},{name:"back-thrust-down-swirl",L0:{from:0,to:.7,phase:0,ecc:.5},L1:{from:.9,to:.1,phase:0,ecc:.5},L2:{from:.8,to:.2,phase:1,ecc:.5},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.8,to:.2,phase:1,ecc:.5},R2:{from:.5,to:1,phase:0,ecc:.5}},{name:"thrust-forward",L0:{from:0,to:.5,phase:0,ecc:.5},L1:{from:.2,to:1,phase:0,ecc:.5},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:.5,to:1,phase:0,ecc:.5}},{name:"thrust-forward-swirl",L0:{from:0,to:.5,phase:0,ecc:.5},L1:{from:.2,to:1,phase:0,ecc:.5},L2:{from:.8,to:.2,phase:1,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.8,to:.2,phase:1,ecc:0},R2:{from:.5,to:1,phase:0,ecc:.5}},{name:"lean-forward-thrust-down",L0:{from:0,to:.7,phase:0,ecc:.5},L1:{from:.5,to:.5,phase:0,ecc:0},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:1,to:0,phase:0,ecc:.5}},{name:"lean-forward-thrust-down-swirl",L0:{from:0,to:.7,phase:0,ecc:.5},L1:{from:.5,to:.5,phase:0,ecc:0},L2:{from:.8,to:.2,phase:1,ecc:.5},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.8,to:.2,phase:1,ecc:.5},R2:{from:1,to:0,phase:0,ecc:.5}},{name:"diagonal-down-back",L0:{from:0,to:.5,phase:0,ecc:.2},L1:{from:1,to:.2,phase:0,ecc:.2},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:1,to:0,phase:1,ecc:.6}},{name:"diagonal-down-forward",L0:{from:0,to:.5,phase:0,ecc:.2},L1:{from:0,to:.8,phase:0,ecc:.2},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:0,to:1,phase:1,ecc:.6}},{name:"orbit-tease",L0:{from:.8,to:1,phase:0,ecc:.3},L1:{from:.9,to:.1,phase:0,ecc:-.3},L2:{from:.1,to:.9,phase:1,ecc:-.3},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.1,to:.9,phase:1,ecc:-.3},R2:{from:.1,to:.9,phase:0,ecc:-.3}},{name:"left-right-tease",L0:{from:.9,to:.9,phase:0,ecc:0},L1:{from:.5,to:.5,phase:0,ecc:0},L2:{from:0,to:1,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:1,to:0,phase:1,ecc:0},R2:{from:.5,to:.5,phase:0,ecc:0}},{name:"forward-back-tease",L0:{from:.9,to:.9,phase:0,ecc:0},L1:{from:0,to:1,phase:0,ecc:0},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:0,to:1,phase:1,ecc:0}},{name:"vortex-tease",L0:{from:.8,to:1,phase:0,ecc:.3},L1:{from:.6,to:.4,phase:0,ecc:0},L2:{from:.4,to:.6,phase:1,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.9,to:.1,phase:1,ecc:0},R2:{from:.9,to:.1,phase:0,ecc:0}},{name:"swirl-tease",L0:{from:.5,to:1,phase:0,ecc:0},L1:{from:1,to:.3,phase:0,ecc:0},L2:{from:1,to:0,phase:1,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.9,to:.1,phase:1,ecc:0},R2:{from:.4,to:1,phase:0,ecc:0}},{name:"forward-back-grind",L0:{from:0,to:0,phase:0,ecc:0},L1:{from:.3,to:.7,phase:0,ecc:0},L2:{from:.5,to:.5,phase:0,ecc:0},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.5,to:.5,phase:0,ecc:0},R2:{from:0,to:1,phase:.5,ecc:0}},{name:"orbit-grind",L0:{from:0,to:.3,phase:0,ecc:.3},L1:{from:0,to:.6,phase:0,ecc:-.3},L2:{from:.2,to:.8,phase:1,ecc:-.3},R0:{from:.5,to:.5,phase:0,ecc:0},R1:{from:.1,to:.9,phase:1,ecc:-.3},R2:{from:.9,to:.1,phase:0,ecc:-.3}}].reduce(((e,t)=>{const{name:s}=t;return delete t.name,e[s]=t,e}),{});class w extends m{#re;#ae;#ne;get angle(){return this.#re}set angle(e){this.#re=e}get bpm(){return this.#ae}static#ce=36;static set granularity(e){if(!r(e,1))throw new Error(`Invalid granularity: ${e}`);w.#ce=e}static get granularity(){return w.#ce}static get DEFAULT_PARAMETERS(){return{from:0,to:1,phase:0,ecc:0,shift:0,construct:f.tempestMotion}}static get library(){return JSON.parse(JSON.stringify(b))}constructor(e,t=60,s=0){if(super(),"string"==typeof e){if(!n(b,e))throw new Error(`No stroke named ${e} found.`);e=b[e]}a(this,"axes",{}),Object.keys(e).forEach((t=>{a(this.axes,t,{}),Object.keys(e[t]).forEach((s=>{a(this.axes[t],s,e[t][s])})),Object.keys(w.DEFAULT_PARAMETERS).forEach((s=>{n(e[t],s)||a(this.axes[t],s,w.DEFAULT_PARAMETERS[s])}))})),this.#re=s,this.#ne=y.createFrom(t),this.#ae=this.#ne.next()}*generate(){const{granularity:e}=w;for(let t=0;t<e;t++)yield this.#he(t);this.#re+=Math.PI}*start(e,t){const s=this.getStartMoves(e,t);yield s}getStartMoves(e,t){const s={};t&&(n(t,"speed")||n(t,"duration"))||(s.speed=1);const o={};return[...Object.keys(this.axes).map((i=>{o[e.getAxis(i).name]=!0;const r=this.axes[i];return{axis:i,to:r.construct(r.from,r.to,r.phase,r.ecc,this.#ae,r.shift+this.#re)({index:-1,frequency:e.frequency}),...s,...t}})),...e.getAxes().filter((e=>!o[e.name])).map((e=>{const o={axis:e.name,to:e.defaultValue,...s,...t};return"boolean"===e.type&&(delete o.speed,delete o.duration),o}))]}transition(e,t=60,s=1,o=null,i=null){return new A(e,t,this,s,o,i)}#he(e){const{granularity:t}=w,s=Object.keys(this.axes).map((s=>{const o=this.axes[s],i=30/t,r=Math.PI/t;return{axis:s,value:o.construct(o.from,o.to,o.phase,o.ecc,this.#ae,o.shift+this.#re+e*r),duration:i/this.#ae}}));return this.#ae=this.#ne.next(),s}}class A extends w{#ee;#ue;#pe;#le;constructor(e,t,s,o,i,r){super(e,t),this.angle=R.computeTransitionStartAngle(s,o,this.bpm),this.#ue=new R(s,this,o),this.#ee=e,this.#pe=i,this.#le=r,s.ayva&&(this.bind(s.ayva),this.#ue.bind(s.ayva))}*generate(e){this.#ue.complete||(this.#pe instanceof Function&&this.#pe(this.#ue.duration,this.bpm),yield*this.#ue(),this.#le instanceof Function&&this.#le(this.#ee,this.bpm)),yield*super.generate(e)}}class R extends m{#me;#de;#Y;get duration(){return this.#Y}constructor(e,t,s){super(),this.#me=e,this.#de=t,this.#Y=s}*generate(e){if("object"!=typeof e||"Ayva"!==e.constructor.name)throw new TypeError(`Invalid Ayva instance: ${e}`);const t={...w.DEFAULT_PARAMETERS,from:.5,to:.5},s={...w.DEFAULT_PARAMETERS,from:0,to:0},o=this.#fe(this.#me.axes,e),i=this.#fe(this.#de.axes,e),r={};Object.keys(i).forEach((a=>{const n="auxiliary"===e.getAxis(a).type?s:t,c=o[a]??{...n},h=i[a];r[a]=this.#ve(c,h)})),Object.keys(o).forEach((i=>{if(!r[i]){const a="auxiliary"===e.getAxis(i).type?s:t,n=o[i],c={...a};r[i]=this.#ve(n,c)}}));const a=[];Object.keys(r).forEach((e=>{a.push({axis:e,...r[e]})})),yield a,this.complete=!0}#ve(e,t){const s=this.#me.bpm,o=(this.#me.bpm+this.#de.bpm)/2;return{value:i=>{const{x:r}=i,a=f.map(r,0,1,e.from,t.from),n=f.map(r,0,1,e.to,t.to),c=f.map(r,0,1,e.phase,t.phase),h=f.map(r,0,1,e.ecc,t.ecc),u=f.map(r,0,1,s,o);return f.blendMotion(e.construct(a,n,c,h,u,this.#me.angle),t.construct(a,n,c,h,u,this.#me.angle),r)(i)},duration:this.#Y}}#fe(e,t){return Object.keys(e).reduce(((s,o)=>(s[t.getAxis(o).name]=e[o],s)),{})}static computeTransitionStartAngle(e,t,s){const o=(e.bpm+s)/2;return e.angle+2*Math.PI*(o/60)*t}}const M=w,E=class{#ye;#ge;constructor(e,t){if(r(e,0)&&void 0===t)this.#ge=1e3*e;else{if(!(r(e,0)&&r(t,0)&&e<t))throw new Error(`Invalid duration range: (${e}, ${t})`);this.#ge=1e3*(Math.random()*(t-e)+e)}this.#ye=performance.now()}get targetElapsed(){return this.#ge}get complete(){return performance.now()-this.#ye>=this.#ge}get percentage(){return i((performance.now()-this.#ye)/this.#ge,0,1)}},P=class{connected=!1;_baudRate;_output=null;_input=null;_serial=null;constructor(e=115200,t=null){this._baudRate=e,this._serial=t||(globalThis.navigator?globalThis.navigator.serial:null)}async requestConnection(){const e=await this._serial.requestPort();await e.open({baudRate:this._baudRate});const t=new TextEncoderStream;t.readable.pipeTo(e.writable);const s=new TextDecoderStream;e.readable.pipeTo(s.writable),this._output=t.writable.getWriter(),this._input=s.readable.getReader(),this.connected=!0;const o=t=>{t.target===e&&(this.connected=!1,this._serial.removeEventListener("disconnect",o))};return this._serial.addEventListener("disconnect",o),new Promise((e=>{setTimeout(e,2e3)}))}write(e){if(!this.connected)throw new Error("No device connected.");this._output.write(e)}};var L=t.kZ,$=t.UE,S=t.fV,O=t.we,_=t.ft,k=t.ni,I=t._I,F=t.ZP;export{L as Ayva,$ as AyvaBehavior,S as ClassicStroke,O as GeneratorBehavior,_ as TempestStroke,k as VariableDuration,I as WebSerialDevice,F as default};